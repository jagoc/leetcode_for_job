# array

## 1. Two Sum (Incapable)
### Solution
暴力法，双层循环遍历vector，求解和为target的两个元素的下标；时间复杂度O(n^2)

### Standard Solution
暴力法的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 target - x 的时间复杂度从 O(N) 降低到 O(1)。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。


### 16. 3Sum Closest (Incapable)
### Solution
暴力法：遍历vector，当遍历到位置i，则该问题可转化为剩余数中和最接近 target - nums[i]；继续遍历剩余元素，当遍历到位置j，则该问题可转化为剩余书中值最接近 target - nums[i] - nums[j]的数；
依次递归，即可求解

**超出时间限制-_-**

### Standard Solution
我们首先考虑枚举第一个元素 a，对于剩下的两个元素 b 和 c，我们希望它们的和最接近 target−a 。对于 b 和 c，如果它们在原数组中枚举的范围（既包括下标的范围，也包括元素值的范围）没有任何规律可言，那么我们还是只能使用两重循环来枚举所有的可能情况。因此，我们可以考虑对整个数组进行升序排序，这样一来：

当我们知道了 b 和 c 可以枚举的下标范围，并且知道这一范围对应的数组元素是有序（升序）的，那么我们是否可以对枚举的过程进行优化呢？

答案是可以的。借助双指针，我们就可以对枚举的过程进行优化。我们用 pb 和 pc 分别表示指向 b 和 c 的指针，初始时，pb指向位置 i+1，即左边界；pc指向位置 n−1，即右边界。
在每一步枚举的过程中，我们根据a+b+c与target的大小关系来移动 pb 和 pc。

#### 小优化
1. 当枚举的a+b+c=target时，可以直接返回target
2. 当我们枚举 a,b,c 中任意元素并移动指针时，可以直接将其移动到下一个与这次枚举的不相同的元素，从而减少枚举的次数


### Error (2 times accept)
1. 没有对数组进行排序
2. while的子循环中没有考虑数组下标是否越界